/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AvailableTournament
 */
export interface AvailableTournament {
    /**
     * 
     * @type {number}
     * @memberof AvailableTournament
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof AvailableTournament
     */
    'type': AvailableTournamentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AvailableTournament
     */
    'season'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AvailableTournament
     */
    'hasLinkedTournaments': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AvailableTournament
     */
    'hasMatches': boolean;
    /**
     * 
     * @type {Participant}
     * @memberof AvailableTournament
     */
    'winner': Participant;
    /**
     * 
     * @type {Participant}
     * @memberof AvailableTournament
     */
    'finalist': Participant;
}

export const AvailableTournamentTypeEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;

export type AvailableTournamentTypeEnum = typeof AvailableTournamentTypeEnum[keyof typeof AvailableTournamentTypeEnum];

/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'w': number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'd': number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'l': number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'u': number;
}
/**
 * 
 * @export
 * @interface BaseMatch
 */
export interface BaseMatch {
    /**
     * 
     * @type {number}
     * @memberof BaseMatch
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BaseMatch
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof BaseMatch
     */
    'replayDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseMatch
     */
    'answer': boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseMatch
     */
    'group': BaseMatchGroupEnum;
    /**
     * 
     * @type {number}
     * @memberof BaseMatch
     */
    'tour': number;
    /**
     * 
     * @type {Participant}
     * @memberof BaseMatch
     */
    'host': Participant;
    /**
     * 
     * @type {Participant}
     * @memberof BaseMatch
     */
    'guest': Participant;
    /**
     * 
     * @type {number}
     * @memberof BaseMatch
     */
    'hostScore': number;
    /**
     * 
     * @type {number}
     * @memberof BaseMatch
     */
    'guestScore': number;
    /**
     * 
     * @type {number}
     * @memberof BaseMatch
     */
    'hostPen': number;
    /**
     * 
     * @type {number}
     * @memberof BaseMatch
     */
    'guestPen': number;
    /**
     * 
     * @type {Participant}
     * @memberof BaseMatch
     */
    'forceWinner': Participant;
    /**
     * 
     * @type {boolean}
     * @memberof BaseMatch
     */
    'unplayed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseMatch
     */
    'tech': boolean;
    /**
     * 
     * @type {Array<DeductedPoints>}
     * @memberof BaseMatch
     */
    'deductedPointsList': Array<DeductedPoints>;
}

export const BaseMatchGroupEnum = {
    A: 'A',
    B: 'B',
    C: 'C',
    D: 'D',
    E: 'E',
    F: 'F',
    G: 'G',
    H: 'H',
    I: 'I',
    J: 'J',
    K: 'K',
    L: 'L'
} as const;

export type BaseMatchGroupEnum = typeof BaseMatchGroupEnum[keyof typeof BaseMatchGroupEnum];

/**
 * 
 * @export
 * @interface City
 */
export interface City {
    /**
     * 
     * @type {number}
     * @memberof City
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof City
     */
    'name': string;
    /**
     * 
     * @type {Country}
     * @memberof City
     */
    'country': Country;
    /**
     * 
     * @type {Array<OldCityName>}
     * @memberof City
     */
    'oldNames'?: Array<OldCityName>;
    /**
     * 
     * @type {Array<Club>}
     * @memberof City
     */
    'clubs'?: Array<Club>;
}
/**
 * 
 * @export
 * @interface Club
 */
export interface Club {
    /**
     * 
     * @type {number}
     * @memberof Club
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    'name': string;
    /**
     * 
     * @type {City}
     * @memberof Club
     */
    'city': City;
    /**
     * 
     * @type {Array<OldClubName>}
     * @memberof Club
     */
    'oldNames'?: Array<OldClubName>;
}
/**
 * 
 * @export
 * @interface ClubCV
 */
export interface ClubCV {
    /**
     * 
     * @type {string}
     * @memberof ClubCV
     */
    'start': ClubCVStartEnum;
    /**
     * 
     * @type {string}
     * @memberof ClubCV
     */
    'finish': ClubCVFinishEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ClubCV
     */
    'isWinner'?: boolean;
    /**
     * 
     * @type {Balance}
     * @memberof ClubCV
     */
    'balance': Balance;
    /**
     * 
     * @type {TournamentSeason}
     * @memberof ClubCV
     */
    'tournamentSeason': TournamentSeason;
}

export const ClubCVStartEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type ClubCVStartEnum = typeof ClubCVStartEnum[keyof typeof ClubCVStartEnum];
export const ClubCVFinishEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type ClubCVFinishEnum = typeof ClubCVFinishEnum[keyof typeof ClubCVFinishEnum];

/**
 * 
 * @export
 * @interface ClubTournamentCoefficient
 */
export interface ClubTournamentCoefficient {
    /**
     * 
     * @type {string}
     * @memberof ClubTournamentCoefficient
     */
    'tournament': ClubTournamentCoefficientTournamentEnum;
    /**
     * 
     * @type {number}
     * @memberof ClubTournamentCoefficient
     */
    'coefficient': number;
}

export const ClubTournamentCoefficientTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;

export type ClubTournamentCoefficientTournamentEnum = typeof ClubTournamentCoefficientTournamentEnum[keyof typeof ClubTournamentCoefficientTournamentEnum];

/**
 * 
 * @export
 * @interface ClubWithWinner
 */
export interface ClubWithWinner {
    /**
     * 
     * @type {number}
     * @memberof ClubWithWinner
     */
    'id': number;
    /**
     * 
     * @type {Club}
     * @memberof ClubWithWinner
     */
    'club': Club;
    /**
     * 
     * @type {TournamentSeason}
     * @memberof ClubWithWinner
     */
    'tournamentSeason': TournamentSeason;
    /**
     * 
     * @type {string}
     * @memberof ClubWithWinner
     */
    'startingStage': ClubWithWinnerStartingStageEnum;
    /**
     * 
     * @type {Stage}
     * @memberof ClubWithWinner
     */
    'fromStage': Stage;
    /**
     * 
     * @type {boolean}
     * @memberof ClubWithWinner
     */
    'isWinner'?: boolean;
}

export const ClubWithWinnerStartingStageEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type ClubWithWinnerStartingStageEnum = typeof ClubWithWinnerStartingStageEnum[keyof typeof ClubWithWinnerStartingStageEnum];

/**
 * 
 * @export
 * @interface CoefficientData
 */
export interface CoefficientData {
    /**
     * 
     * @type {Array<SeasonCoefficient>}
     * @memberof CoefficientData
     */
    'seasonCoefficients': Array<SeasonCoefficient>;
    /**
     * 
     * @type {number}
     * @memberof CoefficientData
     */
    'totalCoefficient': number;
    /**
     * 
     * @type {Country}
     * @memberof CoefficientData
     */
    'country': Country;
    /**
     * 
     * @type {number}
     * @memberof CoefficientData
     */
    'coefficient': number;
    /**
     * 
     * @type {Array<CountryClubCoefficient>}
     * @memberof CoefficientData
     */
    'clubs': Array<CountryClubCoefficient>;
}
/**
 * 
 * @export
 * @interface CoefficientHistoryItem
 */
export interface CoefficientHistoryItem {
    /**
     * 
     * @type {string}
     * @memberof CoefficientHistoryItem
     */
    'season': string;
    /**
     * 
     * @type {number}
     * @memberof CoefficientHistoryItem
     */
    'place': number;
    /**
     * 
     * @type {number}
     * @memberof CoefficientHistoryItem
     */
    'places': number;
    /**
     * 
     * @type {number}
     * @memberof CoefficientHistoryItem
     */
    'rank': number;
    /**
     * 
     * @type {number}
     * @memberof CoefficientHistoryItem
     */
    'totalCoefficient': number;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {number}
     * @memberof Country
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'till': string;
}
/**
 * 
 * @export
 * @interface CountryCV
 */
export interface CountryCV {
    /**
     * 
     * @type {TournamentSeason}
     * @memberof CountryCV
     */
    'tournamentSeason': TournamentSeason;
    /**
     * 
     * @type {ClubWithWinner}
     * @memberof CountryCV
     */
    'host': ClubWithWinner;
    /**
     * 
     * @type {ClubWithWinner}
     * @memberof CountryCV
     */
    'guest': ClubWithWinner;
    /**
     * 
     * @type {string}
     * @memberof CountryCV
     */
    'status': CountryCVStatusEnum;
}

export const CountryCVStatusEnum = {
    Winner: 'winner',
    RunnerUp: 'runner-up',
    Both: 'both'
} as const;

export type CountryCVStatusEnum = typeof CountryCVStatusEnum[keyof typeof CountryCVStatusEnum];

/**
 * 
 * @export
 * @interface CountryClubCoefficient
 */
export interface CountryClubCoefficient {
    /**
     * 
     * @type {Club}
     * @memberof CountryClubCoefficient
     */
    'club': Club;
    /**
     * 
     * @type {number}
     * @memberof CountryClubCoefficient
     */
    'coefficient': number;
    /**
     * 
     * @type {Array<ClubTournamentCoefficient>}
     * @memberof CountryClubCoefficient
     */
    'participations': Array<ClubTournamentCoefficient>;
}
/**
 * 
 * @export
 * @interface CreateCityDto
 */
export interface CreateCityDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCityDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateCityDto
     */
    'countryId': number;
}
/**
 * 
 * @export
 * @interface CreateClubDto
 */
export interface CreateClubDto {
    /**
     * 
     * @type {string}
     * @memberof CreateClubDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CreateClubDto
     */
    'cityId': number;
}
/**
 * 
 * @export
 * @interface CreateMatchDto
 */
export interface CreateMatchDto {
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'hostId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'guestId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateMatchDto
     */
    'stageType': CreateMatchDtoStageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateMatchDto
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMatchDto
     */
    'replayDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateMatchDto
     */
    'answer': boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'hostScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'guestScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'hostPen'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'guestPen'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'tour'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateMatchDto
     */
    'group': CreateMatchDtoGroupEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateMatchDto
     */
    'forceWinnerId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateMatchDto
     */
    'unplayed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateMatchDto
     */
    'tech'?: boolean;
    /**
     * 
     * @type {Array<DeductedPointsDto>}
     * @memberof CreateMatchDto
     */
    'deductions'?: Array<DeductedPointsDto>;
}

export const CreateMatchDtoStageTypeEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type CreateMatchDtoStageTypeEnum = typeof CreateMatchDtoStageTypeEnum[keyof typeof CreateMatchDtoStageTypeEnum];
export const CreateMatchDtoGroupEnum = {
    A: 'A',
    B: 'B',
    C: 'C',
    D: 'D',
    E: 'E',
    F: 'F',
    G: 'G',
    H: 'H',
    I: 'I',
    J: 'J',
    K: 'K',
    L: 'L'
} as const;

export type CreateMatchDtoGroupEnum = typeof CreateMatchDtoGroupEnum[keyof typeof CreateMatchDtoGroupEnum];

/**
 * 
 * @export
 * @interface CreateOldCityNameDTO
 */
export interface CreateOldCityNameDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateOldCityNameDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOldCityNameDTO
     */
    'till': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOldCityNameDTO
     */
    'countryId'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateOldCityNameDTO
     */
    'cityId'?: number;
}
/**
 * 
 * @export
 * @interface CreateParticipantDto
 */
export interface CreateParticipantDto {
    /**
     * 
     * @type {number}
     * @memberof CreateParticipantDto
     */
    'clubId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateParticipantDto
     */
    'startingStage': CreateParticipantDtoStartingStageEnum;
}

export const CreateParticipantDtoStartingStageEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type CreateParticipantDtoStartingStageEnum = typeof CreateParticipantDtoStartingStageEnum[keyof typeof CreateParticipantDtoStartingStageEnum];

/**
 * 
 * @export
 * @interface DeductedPoints
 */
export interface DeductedPoints {
    /**
     * 
     * @type {number}
     * @memberof DeductedPoints
     */
    'id': number;
    /**
     * 
     * @type {Match}
     * @memberof DeductedPoints
     */
    'match': Match;
    /**
     * 
     * @type {Participant}
     * @memberof DeductedPoints
     */
    'participant': Participant;
    /**
     * 
     * @type {number}
     * @memberof DeductedPoints
     */
    'points': number;
}
/**
 * 
 * @export
 * @interface DeductedPointsDto
 */
export interface DeductedPointsDto {
    /**
     * 
     * @type {number}
     * @memberof DeductedPointsDto
     */
    'participantId': number;
    /**
     * 
     * @type {number}
     * @memberof DeductedPointsDto
     */
    'points': number;
}
/**
 * 
 * @export
 * @interface DeleteMatchDto
 */
export interface DeleteMatchDto {
    /**
     * 
     * @type {number}
     * @memberof DeleteMatchDto
     */
    'answerMatchId'?: number;
}
/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'replayDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof Match
     */
    'answer': boolean;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'group': MatchGroupEnum;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'tour': number;
    /**
     * 
     * @type {Participant}
     * @memberof Match
     */
    'host': Participant;
    /**
     * 
     * @type {Participant}
     * @memberof Match
     */
    'guest': Participant;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'hostScore': number;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'guestScore': number;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'hostPen': number;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'guestPen': number;
    /**
     * 
     * @type {Participant}
     * @memberof Match
     */
    'forceWinner': Participant;
    /**
     * 
     * @type {boolean}
     * @memberof Match
     */
    'unplayed': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Match
     */
    'tech': boolean;
    /**
     * 
     * @type {Array<DeductedPoints>}
     * @memberof Match
     */
    'deductedPointsList': Array<DeductedPoints>;
    /**
     * 
     * @type {Stage}
     * @memberof Match
     */
    'stage': Stage;
}

export const MatchGroupEnum = {
    A: 'A',
    B: 'B',
    C: 'C',
    D: 'D',
    E: 'E',
    F: 'F',
    G: 'G',
    H: 'H',
    I: 'I',
    J: 'J',
    K: 'K',
    L: 'L'
} as const;

export type MatchGroupEnum = typeof MatchGroupEnum[keyof typeof MatchGroupEnum];

/**
 * 
 * @export
 * @interface OldCityName
 */
export interface OldCityName {
    /**
     * 
     * @type {number}
     * @memberof OldCityName
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OldCityName
     */
    'till': string;
    /**
     * 
     * @type {string}
     * @memberof OldCityName
     */
    'name'?: string;
    /**
     * 
     * @type {City}
     * @memberof OldCityName
     */
    'city': City;
    /**
     * 
     * @type {Country}
     * @memberof OldCityName
     */
    'country'?: Country;
}
/**
 * 
 * @export
 * @interface OldClubName
 */
export interface OldClubName {
    /**
     * 
     * @type {number}
     * @memberof OldClubName
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OldClubName
     */
    'till': string;
    /**
     * 
     * @type {string}
     * @memberof OldClubName
     */
    'name': string;
    /**
     * 
     * @type {Club}
     * @memberof OldClubName
     */
    'club': Club;
}
/**
 * 
 * @export
 * @interface OldClubNameDto
 */
export interface OldClubNameDto {
    /**
     * 
     * @type {string}
     * @memberof OldClubNameDto
     */
    'till': string;
    /**
     * 
     * @type {string}
     * @memberof OldClubNameDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof OldClubNameDto
     */
    'clubId': number;
}
/**
 * 
 * @export
 * @interface Participant
 */
export interface Participant {
    /**
     * 
     * @type {number}
     * @memberof Participant
     */
    'id': number;
    /**
     * 
     * @type {Club}
     * @memberof Participant
     */
    'club': Club;
    /**
     * 
     * @type {TournamentSeason}
     * @memberof Participant
     */
    'tournamentSeason': TournamentSeason;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'startingStage': ParticipantStartingStageEnum;
    /**
     * 
     * @type {Stage}
     * @memberof Participant
     */
    'fromStage': Stage;
}

export const ParticipantStartingStageEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type ParticipantStartingStageEnum = typeof ParticipantStartingStageEnum[keyof typeof ParticipantStartingStageEnum];

/**
 * 
 * @export
 * @interface SeasonCoefficient
 */
export interface SeasonCoefficient {
    /**
     * 
     * @type {number}
     * @memberof SeasonCoefficient
     */
    'season': number;
    /**
     * 
     * @type {number}
     * @memberof SeasonCoefficient
     */
    'coefficient': number;
}
/**
 * 
 * @export
 * @interface SeasonParticipants
 */
export interface SeasonParticipants {
    /**
     * 
     * @type {Country}
     * @memberof SeasonParticipants
     */
    'country': Country;
    /**
     * 
     * @type {Array<SeasonParticipantsClub>}
     * @memberof SeasonParticipants
     */
    'clubs': Array<SeasonParticipantsClub>;
    /**
     * 
     * @type {number}
     * @memberof SeasonParticipants
     */
    'coefficient'?: number;
}
/**
 * 
 * @export
 * @interface SeasonParticipantsClub
 */
export interface SeasonParticipantsClub {
    /**
     * 
     * @type {Club}
     * @memberof SeasonParticipantsClub
     */
    'club': Club;
    /**
     * 
     * @type {Array<SeasonParticipantsClubParticipation>}
     * @memberof SeasonParticipantsClub
     */
    'participations': Array<SeasonParticipantsClubParticipation>;
    /**
     * 
     * @type {number}
     * @memberof SeasonParticipantsClub
     */
    'coefficient'?: number;
}
/**
 * 
 * @export
 * @interface SeasonParticipantsClubParticipation
 */
export interface SeasonParticipantsClubParticipation {
    /**
     * 
     * @type {number}
     * @memberof SeasonParticipantsClubParticipation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SeasonParticipantsClubParticipation
     */
    'tournament': SeasonParticipantsClubParticipationTournamentEnum;
    /**
     * 
     * @type {string}
     * @memberof SeasonParticipantsClubParticipation
     */
    'startingStage': SeasonParticipantsClubParticipationStartingStageEnum;
    /**
     * 
     * @type {Stage}
     * @memberof SeasonParticipantsClubParticipation
     */
    'fromStage': Stage;
}

export const SeasonParticipantsClubParticipationTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;

export type SeasonParticipantsClubParticipationTournamentEnum = typeof SeasonParticipantsClubParticipationTournamentEnum[keyof typeof SeasonParticipantsClubParticipationTournamentEnum];
export const SeasonParticipantsClubParticipationStartingStageEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type SeasonParticipantsClubParticipationStartingStageEnum = typeof SeasonParticipantsClubParticipationStartingStageEnum[keyof typeof SeasonParticipantsClubParticipationStartingStageEnum];

/**
 * 
 * @export
 * @interface Stage
 */
export interface Stage {
    /**
     * 
     * @type {number}
     * @memberof Stage
     */
    'id': number;
    /**
     * 
     * @type {TournamentSeason}
     * @memberof Stage
     */
    'tournamentSeason': TournamentSeason;
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'stageType': StageStageTypeEnum;
    /**
     * 
     * @type {StageScheme}
     * @memberof Stage
     */
    'stageScheme': StageScheme;
    /**
     * 
     * @type {Stage}
     * @memberof Stage
     */
    'previousStage': Stage;
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'linkedTournament': StageLinkedTournamentEnum;
    /**
     * 
     * @type {string}
     * @memberof Stage
     */
    'linkedTournamentStage': StageLinkedTournamentStageEnum;
    /**
     * 
     * @type {Array<StageSubstitution>}
     * @memberof Stage
     */
    'stageSubstitutions': Array<StageSubstitution>;
}

export const StageStageTypeEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type StageStageTypeEnum = typeof StageStageTypeEnum[keyof typeof StageStageTypeEnum];
export const StageLinkedTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;

export type StageLinkedTournamentEnum = typeof StageLinkedTournamentEnum[keyof typeof StageLinkedTournamentEnum];
export const StageLinkedTournamentStageEnum = {
    Pq12F: 'PQ1/2F',
    Pqf: 'PQF',
    Pr: 'PR',
    _1Q: '1Q',
    _2Q: '2Q',
    _3Q: '3Q',
    Poq: 'POQ',
    Lg: 'LG',
    G: 'G',
    G2: 'G_2',
    Kpo: 'KPO',
    _1R: '1R',
    _2R: '2R',
    _3R: '3R',
    R16: 'R16',
    _14F: '1/4F',
    _12F: '1/2F',
    F: 'F'
} as const;

export type StageLinkedTournamentStageEnum = typeof StageLinkedTournamentStageEnum[keyof typeof StageLinkedTournamentStageEnum];

/**
 * 
 * @export
 * @interface StageScheme
 */
export interface StageScheme {
    /**
     * 
     * @type {number}
     * @memberof StageScheme
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StageScheme
     */
    'type': StageSchemeTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof StageScheme
     */
    'isStarting': boolean;
    /**
     * 
     * @type {number}
     * @memberof StageScheme
     */
    'groups'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StageScheme
     */
    'pen': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StageScheme
     */
    'awayGoal': boolean;
    /**
     * 
     * @type {number}
     * @memberof StageScheme
     */
    'swissNum'?: number;
}

export const StageSchemeTypeEnum = {
    Olympic1: 'OLYMPIC_1',
    Olympic2: 'OLYMPIC_2',
    Group: 'GROUP',
    Group5: 'GROUP_5',
    Group12F: 'GROUP_1/2F',
    GroupIcfc: 'GROUP_ICFC',
    League: 'LEAGUE'
} as const;

export type StageSchemeTypeEnum = typeof StageSchemeTypeEnum[keyof typeof StageSchemeTypeEnum];

/**
 * 
 * @export
 * @interface StageSubstitution
 */
export interface StageSubstitution {
    /**
     * 
     * @type {number}
     * @memberof StageSubstitution
     */
    'id': number;
    /**
     * 
     * @type {Stage}
     * @memberof StageSubstitution
     */
    'stage': Stage;
    /**
     * 
     * @type {Participant}
     * @memberof StageSubstitution
     */
    'expelled': Participant;
    /**
     * 
     * @type {Participant}
     * @memberof StageSubstitution
     */
    'sub': Participant;
}
/**
 * 
 * @export
 * @interface StageSubstitutionDto
 */
export interface StageSubstitutionDto {
    /**
     * 
     * @type {number}
     * @memberof StageSubstitutionDto
     */
    'stageId': number;
    /**
     * 
     * @type {number}
     * @memberof StageSubstitutionDto
     */
    'expelledId': number;
    /**
     * 
     * @type {number}
     * @memberof StageSubstitutionDto
     */
    'subId': number;
}
/**
 * 
 * @export
 * @interface TokensPairResponse
 */
export interface TokensPairResponse {
    /**
     * 
     * @type {string}
     * @memberof TokensPairResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof TokensPairResponse
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface TournamentPart
 */
export interface TournamentPart {
    /**
     * 
     * @type {Stage}
     * @memberof TournamentPart
     */
    'stage': Stage;
    /**
     * 
     * @type {Array<BaseMatch>}
     * @memberof TournamentPart
     */
    'matches': Array<BaseMatch>;
}
/**
 * 
 * @export
 * @interface TournamentSeason
 */
export interface TournamentSeason {
    /**
     * 
     * @type {number}
     * @memberof TournamentSeason
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TournamentSeason
     */
    'tournament': TournamentSeasonTournamentEnum;
    /**
     * 
     * @type {string}
     * @memberof TournamentSeason
     */
    'season': string;
}

export const TournamentSeasonTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;

export type TournamentSeasonTournamentEnum = typeof TournamentSeasonTournamentEnum[keyof typeof TournamentSeasonTournamentEnum];

/**
 * 
 * @export
 * @interface UpdateCountryDto
 */
export interface UpdateCountryDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateCountryDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCountryDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCountryDto
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCountryDto
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCountryDto
     */
    'till'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMatchResultDto
 */
export interface UpdateMatchResultDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMatchResultDto
     */
    'date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMatchResultDto
     */
    'answer'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateMatchResultDto
     */
    'hostScore': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateMatchResultDto
     */
    'guestScore': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateMatchResultDto
     */
    'hostPen'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateMatchResultDto
     */
    'guestPen'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateMatchResultDto
     */
    'forceWinnerId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMatchResultDto
     */
    'unplayed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMatchResultDto
     */
    'tech'?: boolean;
    /**
     * 
     * @type {Array<DeductedPointsDto>}
     * @memberof UpdateMatchResultDto
     */
    'deductions'?: Array<DeductedPointsDto>;
}
/**
 * 
 * @export
 * @interface Winner
 */
export interface Winner {
    /**
     * 
     * @type {TournamentSeason}
     * @memberof Winner
     */
    'tournament': TournamentSeason;
    /**
     * 
     * @type {Participant}
     * @memberof Winner
     */
    'winner': Participant;
    /**
     * 
     * @type {Participant}
     * @memberof Winner
     */
    'finalist': Participant;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleAuth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleAuthRedirect: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/redirect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGoogleAuth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGoogleAuth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGoogleAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGoogleAuthRedirect(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGoogleAuthRedirect(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGoogleAuthRedirect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefreshTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensPairResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefreshTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefreshTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleAuth(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerGoogleAuth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleAuthRedirect(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerGoogleAuthRedirect(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefreshTokens(options?: any): AxiosPromise<TokensPairResponse> {
            return localVarFp.authControllerRefreshTokens(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGoogleAuth(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGoogleAuth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGoogleAuthRedirect(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGoogleAuthRedirect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefreshTokens(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefreshTokens(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CityApi - axios parameter creator
 * @export
 */
export const CityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCityDto} createCityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerCreateCity: async (createCityDto: CreateCityDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCityDto' is not null or undefined
            assertParamExists('cityControllerCreateCity', 'createCityDto', createCityDto)
            const localVarPath = `/city`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCityDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateOldCityNameDTO} createOldCityNameDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerCreateCityOldName: async (id: number, createOldCityNameDTO: CreateOldCityNameDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cityControllerCreateCityOldName', 'id', id)
            // verify required parameter 'createOldCityNameDTO' is not null or undefined
            assertParamExists('cityControllerCreateCityOldName', 'createOldCityNameDTO', createOldCityNameDTO)
            const localVarPath = `/city/{id}/old-name`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOldCityNameDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerDeleteCity: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cityControllerDeleteCity', 'id', id)
            const localVarPath = `/city/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerDeleteCityOldName: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cityControllerDeleteCityOldName', 'id', id)
            const localVarPath = `/city/old-name/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} withoutClubs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerGetCities: async (withoutClubs: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withoutClubs' is not null or undefined
            assertParamExists('cityControllerGetCities', 'withoutClubs', withoutClubs)
            const localVarPath = `/city`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withoutClubs !== undefined) {
                localVarQueryParameter['withoutClubs'] = withoutClubs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {City} city 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerUpdateCity: async (id: number, city: City, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cityControllerUpdateCity', 'id', id)
            // verify required parameter 'city' is not null or undefined
            assertParamExists('cityControllerUpdateCity', 'city', city)
            const localVarPath = `/city/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(city, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CityApi - functional programming interface
 * @export
 */
export const CityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCityDto} createCityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cityControllerCreateCity(createCityDto: CreateCityDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cityControllerCreateCity(createCityDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CityApi.cityControllerCreateCity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateOldCityNameDTO} createOldCityNameDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cityControllerCreateCityOldName(id: number, createOldCityNameDTO: CreateOldCityNameDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOldCityNameDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cityControllerCreateCityOldName(id, createOldCityNameDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CityApi.cityControllerCreateCityOldName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cityControllerDeleteCity(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cityControllerDeleteCity(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CityApi.cityControllerDeleteCity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cityControllerDeleteCityOldName(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cityControllerDeleteCityOldName(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CityApi.cityControllerDeleteCityOldName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} withoutClubs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cityControllerGetCities(withoutClubs: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<City>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cityControllerGetCities(withoutClubs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CityApi.cityControllerGetCities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {City} city 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cityControllerUpdateCity(id: number, city: City, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<City>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cityControllerUpdateCity(id, city, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CityApi.cityControllerUpdateCity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CityApi - factory interface
 * @export
 */
export const CityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CityApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCityDto} createCityDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerCreateCity(createCityDto: CreateCityDto, options?: any): AxiosPromise<City> {
            return localVarFp.cityControllerCreateCity(createCityDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateOldCityNameDTO} createOldCityNameDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerCreateCityOldName(id: number, createOldCityNameDTO: CreateOldCityNameDTO, options?: any): AxiosPromise<CreateOldCityNameDTO> {
            return localVarFp.cityControllerCreateCityOldName(id, createOldCityNameDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerDeleteCity(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.cityControllerDeleteCity(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerDeleteCityOldName(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.cityControllerDeleteCityOldName(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} withoutClubs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerGetCities(withoutClubs: boolean, options?: any): AxiosPromise<Array<City>> {
            return localVarFp.cityControllerGetCities(withoutClubs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {City} city 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cityControllerUpdateCity(id: number, city: City, options?: any): AxiosPromise<City> {
            return localVarFp.cityControllerUpdateCity(id, city, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CityApi - object-oriented interface
 * @export
 * @class CityApi
 * @extends {BaseAPI}
 */
export class CityApi extends BaseAPI {
    /**
     * 
     * @param {CreateCityDto} createCityDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public cityControllerCreateCity(createCityDto: CreateCityDto, options?: RawAxiosRequestConfig) {
        return CityApiFp(this.configuration).cityControllerCreateCity(createCityDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateOldCityNameDTO} createOldCityNameDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public cityControllerCreateCityOldName(id: number, createOldCityNameDTO: CreateOldCityNameDTO, options?: RawAxiosRequestConfig) {
        return CityApiFp(this.configuration).cityControllerCreateCityOldName(id, createOldCityNameDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public cityControllerDeleteCity(id: number, options?: RawAxiosRequestConfig) {
        return CityApiFp(this.configuration).cityControllerDeleteCity(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public cityControllerDeleteCityOldName(id: number, options?: RawAxiosRequestConfig) {
        return CityApiFp(this.configuration).cityControllerDeleteCityOldName(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} withoutClubs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public cityControllerGetCities(withoutClubs: boolean, options?: RawAxiosRequestConfig) {
        return CityApiFp(this.configuration).cityControllerGetCities(withoutClubs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {City} city 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CityApi
     */
    public cityControllerUpdateCity(id: number, city: City, options?: RawAxiosRequestConfig) {
        return CityApiFp(this.configuration).cityControllerUpdateCity(id, city, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClubApi - axios parameter creator
 * @export
 */
export const ClubApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateClubDto} createClubDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerCreateClub: async (createClubDto: CreateClubDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createClubDto' is not null or undefined
            assertParamExists('clubControllerCreateClub', 'createClubDto', createClubDto)
            const localVarPath = `/club`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClubDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {OldClubNameDto} oldClubNameDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerCreateClubOldName: async (id: number, oldClubNameDto: OldClubNameDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clubControllerCreateClubOldName', 'id', id)
            // verify required parameter 'oldClubNameDto' is not null or undefined
            assertParamExists('clubControllerCreateClubOldName', 'oldClubNameDto', oldClubNameDto)
            const localVarPath = `/club/{id}/old-name`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oldClubNameDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerDeleteClub: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clubControllerDeleteClub', 'id', id)
            const localVarPath = `/club/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerDeleteClubOldName: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clubControllerDeleteClubOldName', 'id', id)
            const localVarPath = `/club/old-name/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerGetClub: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clubControllerGetClub', 'id', id)
            const localVarPath = `/club/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerGetClubCV: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clubControllerGetClubCV', 'id', id)
            const localVarPath = `/club/{id}/cv`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerGetClubs: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/club`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Club} club 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerUpdateClub: async (id: number, club: Club, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clubControllerUpdateClub', 'id', id)
            // verify required parameter 'club' is not null or undefined
            assertParamExists('clubControllerUpdateClub', 'club', club)
            const localVarPath = `/club/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(club, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubApi - functional programming interface
 * @export
 */
export const ClubApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClubApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateClubDto} createClubDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerCreateClub(createClubDto: CreateClubDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Club>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerCreateClub(createClubDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerCreateClub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {OldClubNameDto} oldClubNameDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerCreateClubOldName(id: number, oldClubNameDto: OldClubNameDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OldClubName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerCreateClubOldName(id, oldClubNameDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerCreateClubOldName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerDeleteClub(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerDeleteClub(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerDeleteClub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerDeleteClubOldName(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerDeleteClubOldName(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerDeleteClubOldName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerGetClub(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Club>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerGetClub(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerGetClub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerGetClubCV(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClubCV>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerGetClubCV(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerGetClubCV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerGetClubs(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Club>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerGetClubs(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerGetClubs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {Club} club 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubControllerUpdateClub(id: number, club: Club, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Club>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubControllerUpdateClub(id, club, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClubApi.clubControllerUpdateClub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClubApi - factory interface
 * @export
 */
export const ClubApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClubApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateClubDto} createClubDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerCreateClub(createClubDto: CreateClubDto, options?: any): AxiosPromise<Club> {
            return localVarFp.clubControllerCreateClub(createClubDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {OldClubNameDto} oldClubNameDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerCreateClubOldName(id: number, oldClubNameDto: OldClubNameDto, options?: any): AxiosPromise<OldClubName> {
            return localVarFp.clubControllerCreateClubOldName(id, oldClubNameDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerDeleteClub(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.clubControllerDeleteClub(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerDeleteClubOldName(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.clubControllerDeleteClubOldName(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerGetClub(id: number, options?: any): AxiosPromise<Club> {
            return localVarFp.clubControllerGetClub(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerGetClubCV(id: number, options?: any): AxiosPromise<Array<ClubCV>> {
            return localVarFp.clubControllerGetClubCV(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerGetClubs(options?: any): AxiosPromise<Array<Club>> {
            return localVarFp.clubControllerGetClubs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Club} club 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubControllerUpdateClub(id: number, club: Club, options?: any): AxiosPromise<Club> {
            return localVarFp.clubControllerUpdateClub(id, club, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClubApi - object-oriented interface
 * @export
 * @class ClubApi
 * @extends {BaseAPI}
 */
export class ClubApi extends BaseAPI {
    /**
     * 
     * @param {CreateClubDto} createClubDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerCreateClub(createClubDto: CreateClubDto, options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerCreateClub(createClubDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {OldClubNameDto} oldClubNameDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerCreateClubOldName(id: number, oldClubNameDto: OldClubNameDto, options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerCreateClubOldName(id, oldClubNameDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerDeleteClub(id: number, options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerDeleteClub(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerDeleteClubOldName(id: number, options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerDeleteClubOldName(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerGetClub(id: number, options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerGetClub(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerGetClubCV(id: number, options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerGetClubCV(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerGetClubs(options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerGetClubs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Club} club 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubApi
     */
    public clubControllerUpdateClub(id: number, club: Club, options?: RawAxiosRequestConfig) {
        return ClubApiFp(this.configuration).clubControllerUpdateClub(id, club, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CoefficientApi - axios parameter creator
 * @export
 */
export const CoefficientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerCalculateSeasonClubCoefficients: async (season: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('coefficientControllerCalculateSeasonClubCoefficients', 'season', season)
            const localVarPath = `/coefficient/{season}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        coefficientControllerGetAllSeasonClubCoefficients: async (season: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('coefficientControllerGetAllSeasonClubCoefficients', 'season', season)
            const localVarPath = `/coefficient/{season}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerGetCountryCoefficient: async (season: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('coefficientControllerGetCountryCoefficient', 'season', season)
            const localVarPath = `/coefficient/{season}/full`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} countryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerGetCountryCoefficientHistory: async (countryId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('coefficientControllerGetCountryCoefficientHistory', 'countryId', countryId)
            const localVarPath = `/coefficient/country/{countryId}`
                .replace(`{${"countryId"}}`, encodeURIComponent(String(countryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerGetWinners: async (season: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('coefficientControllerGetWinners', 'season', season)
            const localVarPath = `/coefficient/{season}/winners`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoefficientApi - functional programming interface
 * @export
 */
export const CoefficientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoefficientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coefficientControllerCalculateSeasonClubCoefficients(season: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coefficientControllerCalculateSeasonClubCoefficients(season, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoefficientApi.coefficientControllerCalculateSeasonClubCoefficients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async coefficientControllerGetAllSeasonClubCoefficients(season: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coefficientControllerGetAllSeasonClubCoefficients(season, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoefficientApi.coefficientControllerGetAllSeasonClubCoefficients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coefficientControllerGetCountryCoefficient(season: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoefficientData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coefficientControllerGetCountryCoefficient(season, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoefficientApi.coefficientControllerGetCountryCoefficient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} countryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coefficientControllerGetCountryCoefficientHistory(countryId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CoefficientHistoryItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coefficientControllerGetCountryCoefficientHistory(countryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoefficientApi.coefficientControllerGetCountryCoefficientHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coefficientControllerGetWinners(season: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Winner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coefficientControllerGetWinners(season, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoefficientApi.coefficientControllerGetWinners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoefficientApi - factory interface
 * @export
 */
export const CoefficientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoefficientApiFp(configuration)
    return {
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerCalculateSeasonClubCoefficients(season: string, options?: any): AxiosPromise<void> {
            return localVarFp.coefficientControllerCalculateSeasonClubCoefficients(season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        coefficientControllerGetAllSeasonClubCoefficients(season: string, options?: any): AxiosPromise<void> {
            return localVarFp.coefficientControllerGetAllSeasonClubCoefficients(season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerGetCountryCoefficient(season: string, options?: any): AxiosPromise<Array<CoefficientData>> {
            return localVarFp.coefficientControllerGetCountryCoefficient(season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} countryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerGetCountryCoefficientHistory(countryId: number, options?: any): AxiosPromise<Array<CoefficientHistoryItem>> {
            return localVarFp.coefficientControllerGetCountryCoefficientHistory(countryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coefficientControllerGetWinners(season: string, options?: any): AxiosPromise<Array<Winner>> {
            return localVarFp.coefficientControllerGetWinners(season, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoefficientApi - object-oriented interface
 * @export
 * @class CoefficientApi
 * @extends {BaseAPI}
 */
export class CoefficientApi extends BaseAPI {
    /**
     * 
     * @param {string} season 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoefficientApi
     */
    public coefficientControllerCalculateSeasonClubCoefficients(season: string, options?: RawAxiosRequestConfig) {
        return CoefficientApiFp(this.configuration).coefficientControllerCalculateSeasonClubCoefficients(season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} season 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CoefficientApi
     */
    public coefficientControllerGetAllSeasonClubCoefficients(season: string, options?: RawAxiosRequestConfig) {
        return CoefficientApiFp(this.configuration).coefficientControllerGetAllSeasonClubCoefficients(season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoefficientApi
     */
    public coefficientControllerGetCountryCoefficient(season: string, options?: RawAxiosRequestConfig) {
        return CoefficientApiFp(this.configuration).coefficientControllerGetCountryCoefficient(season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} countryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoefficientApi
     */
    public coefficientControllerGetCountryCoefficientHistory(countryId: number, options?: RawAxiosRequestConfig) {
        return CoefficientApiFp(this.configuration).coefficientControllerGetCountryCoefficientHistory(countryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoefficientApi
     */
    public coefficientControllerGetWinners(season: string, options?: RawAxiosRequestConfig) {
        return CoefficientApiFp(this.configuration).coefficientControllerGetWinners(season, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountryApi - axios parameter creator
 * @export
 */
export const CountryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryControllerGetCountries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryControllerGetCountryCV: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('countryControllerGetCountryCV', 'id', id)
            const localVarPath = `/country/{id}/cv`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCountryDto} updateCountryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryControllerUpdateCountry: async (id: number, updateCountryDto: UpdateCountryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('countryControllerUpdateCountry', 'id', id)
            // verify required parameter 'updateCountryDto' is not null or undefined
            assertParamExists('countryControllerUpdateCountry', 'updateCountryDto', updateCountryDto)
            const localVarPath = `/country/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCountryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryApi - functional programming interface
 * @export
 */
export const CountryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryControllerGetCountries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Country>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryControllerGetCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryControllerGetCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryControllerGetCountryCV(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryCV>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryControllerGetCountryCV(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryControllerGetCountryCV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCountryDto} updateCountryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryControllerUpdateCountry(id: number, updateCountryDto: UpdateCountryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryControllerUpdateCountry(id, updateCountryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryApi.countryControllerUpdateCountry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryApi - factory interface
 * @export
 */
export const CountryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryControllerGetCountries(options?: any): AxiosPromise<Array<Country>> {
            return localVarFp.countryControllerGetCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryControllerGetCountryCV(id: number, options?: any): AxiosPromise<Array<CountryCV>> {
            return localVarFp.countryControllerGetCountryCV(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateCountryDto} updateCountryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryControllerUpdateCountry(id: number, updateCountryDto: UpdateCountryDto, options?: any): AxiosPromise<Country> {
            return localVarFp.countryControllerUpdateCountry(id, updateCountryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryApi - object-oriented interface
 * @export
 * @class CountryApi
 * @extends {BaseAPI}
 */
export class CountryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryControllerGetCountries(options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryControllerGetCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryControllerGetCountryCV(id: number, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryControllerGetCountryCV(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateCountryDto} updateCountryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryApi
     */
    public countryControllerUpdateCountry(id: number, updateCountryDto: UpdateCountryDto, options?: RawAxiosRequestConfig) {
        return CountryApiFp(this.configuration).countryControllerUpdateCountry(id, updateCountryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatchApi - axios parameter creator
 * @export
 */
export const MatchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} season 
         * @param {MatchControllerCreateMatchTournamentEnum} tournament 
         * @param {CreateMatchDto} createMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerCreateMatch: async (season: string, tournament: MatchControllerCreateMatchTournamentEnum, createMatchDto: CreateMatchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('matchControllerCreateMatch', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('matchControllerCreateMatch', 'tournament', tournament)
            // verify required parameter 'createMatchDto' is not null or undefined
            assertParamExists('matchControllerCreateMatch', 'createMatchDto', createMatchDto)
            const localVarPath = `/match/{season}/{tournament}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMatchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {DeleteMatchDto} deleteMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerDeleteMatch: async (id: number, deleteMatchDto: DeleteMatchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('matchControllerDeleteMatch', 'id', id)
            // verify required parameter 'deleteMatchDto' is not null or undefined
            assertParamExists('matchControllerDeleteMatch', 'deleteMatchDto', deleteMatchDto)
            const localVarPath = `/match/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMatchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {DeleteMatchDto} deleteMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerDeleteMatchResults: async (id: number, deleteMatchDto: DeleteMatchDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('matchControllerDeleteMatchResults', 'id', id)
            // verify required parameter 'deleteMatchDto' is not null or undefined
            assertParamExists('matchControllerDeleteMatchResults', 'deleteMatchDto', deleteMatchDto)
            const localVarPath = `/match/{id}/results`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteMatchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetAllSeasonMatches: async (season: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('matchControllerGetAllSeasonMatches', 'season', season)
            const localVarPath = `/match/{season}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {MatchControllerGetMatchesTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetMatches: async (season: string, tournament: MatchControllerGetMatchesTournamentEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('matchControllerGetMatches', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('matchControllerGetMatches', 'tournament', tournament)
            const localVarPath = `/match/{season}/{tournament}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} countryId 
         * @param {number} rivalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetTwoCountriesMatches: async (countryId: number, rivalId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            assertParamExists('matchControllerGetTwoCountriesMatches', 'countryId', countryId)
            // verify required parameter 'rivalId' is not null or undefined
            assertParamExists('matchControllerGetTwoCountriesMatches', 'rivalId', rivalId)
            const localVarPath = `/match/combat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (rivalId !== undefined) {
                localVarQueryParameter['rivalId'] = rivalId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateMatchResultDto} updateMatchResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerSetResults: async (id: number, updateMatchResultDto: UpdateMatchResultDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('matchControllerSetResults', 'id', id)
            // verify required parameter 'updateMatchResultDto' is not null or undefined
            assertParamExists('matchControllerSetResults', 'updateMatchResultDto', updateMatchResultDto)
            const localVarPath = `/match/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMatchResultDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchApi - functional programming interface
 * @export
 */
export const MatchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} season 
         * @param {MatchControllerCreateMatchTournamentEnum} tournament 
         * @param {CreateMatchDto} createMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerCreateMatch(season: string, tournament: MatchControllerCreateMatchTournamentEnum, createMatchDto: CreateMatchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerCreateMatch(season, tournament, createMatchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchApi.matchControllerCreateMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {DeleteMatchDto} deleteMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerDeleteMatch(id: number, deleteMatchDto: DeleteMatchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerDeleteMatch(id, deleteMatchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchApi.matchControllerDeleteMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {DeleteMatchDto} deleteMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerDeleteMatchResults(id: number, deleteMatchDto: DeleteMatchDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerDeleteMatchResults(id, deleteMatchDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchApi.matchControllerDeleteMatchResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerGetAllSeasonMatches(season: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Match>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerGetAllSeasonMatches(season, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchApi.matchControllerGetAllSeasonMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {MatchControllerGetMatchesTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerGetMatches(season: string, tournament: MatchControllerGetMatchesTournamentEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TournamentPart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerGetMatches(season, tournament, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchApi.matchControllerGetMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} countryId 
         * @param {number} rivalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerGetTwoCountriesMatches(countryId: number, rivalId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Match>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerGetTwoCountriesMatches(countryId, rivalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchApi.matchControllerGetTwoCountriesMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateMatchResultDto} updateMatchResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerSetResults(id: number, updateMatchResultDto: UpdateMatchResultDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Match>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerSetResults(id, updateMatchResultDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchApi.matchControllerSetResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MatchApi - factory interface
 * @export
 */
export const MatchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchApiFp(configuration)
    return {
        /**
         * 
         * @param {string} season 
         * @param {MatchControllerCreateMatchTournamentEnum} tournament 
         * @param {CreateMatchDto} createMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerCreateMatch(season: string, tournament: MatchControllerCreateMatchTournamentEnum, createMatchDto: CreateMatchDto, options?: any): AxiosPromise<Match> {
            return localVarFp.matchControllerCreateMatch(season, tournament, createMatchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {DeleteMatchDto} deleteMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerDeleteMatch(id: number, deleteMatchDto: DeleteMatchDto, options?: any): AxiosPromise<void> {
            return localVarFp.matchControllerDeleteMatch(id, deleteMatchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {DeleteMatchDto} deleteMatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerDeleteMatchResults(id: number, deleteMatchDto: DeleteMatchDto, options?: any): AxiosPromise<void> {
            return localVarFp.matchControllerDeleteMatchResults(id, deleteMatchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetAllSeasonMatches(season: string, options?: any): AxiosPromise<Array<Match>> {
            return localVarFp.matchControllerGetAllSeasonMatches(season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {MatchControllerGetMatchesTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetMatches(season: string, tournament: MatchControllerGetMatchesTournamentEnum, options?: any): AxiosPromise<Array<TournamentPart>> {
            return localVarFp.matchControllerGetMatches(season, tournament, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} countryId 
         * @param {number} rivalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetTwoCountriesMatches(countryId: number, rivalId: number, options?: any): AxiosPromise<Array<Match>> {
            return localVarFp.matchControllerGetTwoCountriesMatches(countryId, rivalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateMatchResultDto} updateMatchResultDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerSetResults(id: number, updateMatchResultDto: UpdateMatchResultDto, options?: any): AxiosPromise<Match> {
            return localVarFp.matchControllerSetResults(id, updateMatchResultDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchApi - object-oriented interface
 * @export
 * @class MatchApi
 * @extends {BaseAPI}
 */
export class MatchApi extends BaseAPI {
    /**
     * 
     * @param {string} season 
     * @param {MatchControllerCreateMatchTournamentEnum} tournament 
     * @param {CreateMatchDto} createMatchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public matchControllerCreateMatch(season: string, tournament: MatchControllerCreateMatchTournamentEnum, createMatchDto: CreateMatchDto, options?: RawAxiosRequestConfig) {
        return MatchApiFp(this.configuration).matchControllerCreateMatch(season, tournament, createMatchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {DeleteMatchDto} deleteMatchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public matchControllerDeleteMatch(id: number, deleteMatchDto: DeleteMatchDto, options?: RawAxiosRequestConfig) {
        return MatchApiFp(this.configuration).matchControllerDeleteMatch(id, deleteMatchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {DeleteMatchDto} deleteMatchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public matchControllerDeleteMatchResults(id: number, deleteMatchDto: DeleteMatchDto, options?: RawAxiosRequestConfig) {
        return MatchApiFp(this.configuration).matchControllerDeleteMatchResults(id, deleteMatchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public matchControllerGetAllSeasonMatches(season: string, options?: RawAxiosRequestConfig) {
        return MatchApiFp(this.configuration).matchControllerGetAllSeasonMatches(season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {MatchControllerGetMatchesTournamentEnum} tournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public matchControllerGetMatches(season: string, tournament: MatchControllerGetMatchesTournamentEnum, options?: RawAxiosRequestConfig) {
        return MatchApiFp(this.configuration).matchControllerGetMatches(season, tournament, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} countryId 
     * @param {number} rivalId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public matchControllerGetTwoCountriesMatches(countryId: number, rivalId: number, options?: RawAxiosRequestConfig) {
        return MatchApiFp(this.configuration).matchControllerGetTwoCountriesMatches(countryId, rivalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateMatchResultDto} updateMatchResultDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public matchControllerSetResults(id: number, updateMatchResultDto: UpdateMatchResultDto, options?: RawAxiosRequestConfig) {
        return MatchApiFp(this.configuration).matchControllerSetResults(id, updateMatchResultDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MatchControllerCreateMatchTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type MatchControllerCreateMatchTournamentEnum = typeof MatchControllerCreateMatchTournamentEnum[keyof typeof MatchControllerCreateMatchTournamentEnum];
/**
 * @export
 */
export const MatchControllerGetMatchesTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type MatchControllerGetMatchesTournamentEnum = typeof MatchControllerGetMatchesTournamentEnum[keyof typeof MatchControllerGetMatchesTournamentEnum];


/**
 * ParticipantApi - axios parameter creator
 * @export
 */
export const ParticipantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerAddParticipantsFromAnotherTournament: async (season: string, tournament: ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('participantControllerAddParticipantsFromAnotherTournament', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('participantControllerAddParticipantsFromAnotherTournament', 'tournament', tournament)
            const localVarPath = `/participant/{season}/{tournament}/add-from-other-tournament`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerCopyParticipantsFromPreviousSeason: async (season: string, tournament: ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('participantControllerCopyParticipantsFromPreviousSeason', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('participantControllerCopyParticipantsFromPreviousSeason', 'tournament', tournament)
            const localVarPath = `/participant/{season}/{tournament}/copy-from-prev-season`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerCreateParticipantTournamentEnum} tournament 
         * @param {CreateParticipantDto} createParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerCreateParticipant: async (season: string, tournament: ParticipantControllerCreateParticipantTournamentEnum, createParticipantDto: CreateParticipantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('participantControllerCreateParticipant', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('participantControllerCreateParticipant', 'tournament', tournament)
            // verify required parameter 'createParticipantDto' is not null or undefined
            assertParamExists('participantControllerCreateParticipant', 'createParticipantDto', createParticipantDto)
            const localVarPath = `/participant/{season}/{tournament}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createParticipantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerDeleteParticipant: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('participantControllerDeleteParticipant', 'id', id)
            const localVarPath = `/participant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerGetAllParticipants: async (season: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('participantControllerGetAllParticipants', 'season', season)
            const localVarPath = `/participant/{season}/all`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerGetParticipantsTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerGetParticipants: async (season: string, tournament: ParticipantControllerGetParticipantsTournamentEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('participantControllerGetParticipants', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('participantControllerGetParticipants', 'tournament', tournament)
            const localVarPath = `/participant/{season}/{tournament}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateParticipantDto} createParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerUpdateParticipant: async (id: number, createParticipantDto: CreateParticipantDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('participantControllerUpdateParticipant', 'id', id)
            // verify required parameter 'createParticipantDto' is not null or undefined
            assertParamExists('participantControllerUpdateParticipant', 'createParticipantDto', createParticipantDto)
            const localVarPath = `/participant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createParticipantDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticipantApi - functional programming interface
 * @export
 */
export const ParticipantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParticipantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participantControllerAddParticipantsFromAnotherTournament(season: string, tournament: ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participantControllerAddParticipantsFromAnotherTournament(season, tournament, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantApi.participantControllerAddParticipantsFromAnotherTournament']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participantControllerCopyParticipantsFromPreviousSeason(season: string, tournament: ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participantControllerCopyParticipantsFromPreviousSeason(season, tournament, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantApi.participantControllerCopyParticipantsFromPreviousSeason']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerCreateParticipantTournamentEnum} tournament 
         * @param {CreateParticipantDto} createParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participantControllerCreateParticipant(season: string, tournament: ParticipantControllerCreateParticipantTournamentEnum, createParticipantDto: CreateParticipantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participantControllerCreateParticipant(season, tournament, createParticipantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantApi.participantControllerCreateParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participantControllerDeleteParticipant(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participantControllerDeleteParticipant(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantApi.participantControllerDeleteParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participantControllerGetAllParticipants(season: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SeasonParticipants>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participantControllerGetAllParticipants(season, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantApi.participantControllerGetAllParticipants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerGetParticipantsTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participantControllerGetParticipants(season: string, tournament: ParticipantControllerGetParticipantsTournamentEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Participant>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participantControllerGetParticipants(season, tournament, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantApi.participantControllerGetParticipants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateParticipantDto} createParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async participantControllerUpdateParticipant(id: number, createParticipantDto: CreateParticipantDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Participant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.participantControllerUpdateParticipant(id, createParticipantDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ParticipantApi.participantControllerUpdateParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ParticipantApi - factory interface
 * @export
 */
export const ParticipantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParticipantApiFp(configuration)
    return {
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerAddParticipantsFromAnotherTournament(season: string, tournament: ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum, options?: any): AxiosPromise<void> {
            return localVarFp.participantControllerAddParticipantsFromAnotherTournament(season, tournament, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerCopyParticipantsFromPreviousSeason(season: string, tournament: ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum, options?: any): AxiosPromise<void> {
            return localVarFp.participantControllerCopyParticipantsFromPreviousSeason(season, tournament, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerCreateParticipantTournamentEnum} tournament 
         * @param {CreateParticipantDto} createParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerCreateParticipant(season: string, tournament: ParticipantControllerCreateParticipantTournamentEnum, createParticipantDto: CreateParticipantDto, options?: any): AxiosPromise<Participant> {
            return localVarFp.participantControllerCreateParticipant(season, tournament, createParticipantDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerDeleteParticipant(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.participantControllerDeleteParticipant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerGetAllParticipants(season: string, options?: any): AxiosPromise<Array<SeasonParticipants>> {
            return localVarFp.participantControllerGetAllParticipants(season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {ParticipantControllerGetParticipantsTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerGetParticipants(season: string, tournament: ParticipantControllerGetParticipantsTournamentEnum, options?: any): AxiosPromise<Array<Participant>> {
            return localVarFp.participantControllerGetParticipants(season, tournament, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateParticipantDto} createParticipantDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        participantControllerUpdateParticipant(id: number, createParticipantDto: CreateParticipantDto, options?: any): AxiosPromise<Participant> {
            return localVarFp.participantControllerUpdateParticipant(id, createParticipantDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParticipantApi - object-oriented interface
 * @export
 * @class ParticipantApi
 * @extends {BaseAPI}
 */
export class ParticipantApi extends BaseAPI {
    /**
     * 
     * @param {string} season 
     * @param {ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum} tournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantApi
     */
    public participantControllerAddParticipantsFromAnotherTournament(season: string, tournament: ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum, options?: RawAxiosRequestConfig) {
        return ParticipantApiFp(this.configuration).participantControllerAddParticipantsFromAnotherTournament(season, tournament, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum} tournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantApi
     */
    public participantControllerCopyParticipantsFromPreviousSeason(season: string, tournament: ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum, options?: RawAxiosRequestConfig) {
        return ParticipantApiFp(this.configuration).participantControllerCopyParticipantsFromPreviousSeason(season, tournament, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {ParticipantControllerCreateParticipantTournamentEnum} tournament 
     * @param {CreateParticipantDto} createParticipantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantApi
     */
    public participantControllerCreateParticipant(season: string, tournament: ParticipantControllerCreateParticipantTournamentEnum, createParticipantDto: CreateParticipantDto, options?: RawAxiosRequestConfig) {
        return ParticipantApiFp(this.configuration).participantControllerCreateParticipant(season, tournament, createParticipantDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantApi
     */
    public participantControllerDeleteParticipant(id: number, options?: RawAxiosRequestConfig) {
        return ParticipantApiFp(this.configuration).participantControllerDeleteParticipant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantApi
     */
    public participantControllerGetAllParticipants(season: string, options?: RawAxiosRequestConfig) {
        return ParticipantApiFp(this.configuration).participantControllerGetAllParticipants(season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {ParticipantControllerGetParticipantsTournamentEnum} tournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantApi
     */
    public participantControllerGetParticipants(season: string, tournament: ParticipantControllerGetParticipantsTournamentEnum, options?: RawAxiosRequestConfig) {
        return ParticipantApiFp(this.configuration).participantControllerGetParticipants(season, tournament, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateParticipantDto} createParticipantDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantApi
     */
    public participantControllerUpdateParticipant(id: number, createParticipantDto: CreateParticipantDto, options?: RawAxiosRequestConfig) {
        return ParticipantApiFp(this.configuration).participantControllerUpdateParticipant(id, createParticipantDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum = typeof ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum[keyof typeof ParticipantControllerAddParticipantsFromAnotherTournamentTournamentEnum];
/**
 * @export
 */
export const ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum = typeof ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum[keyof typeof ParticipantControllerCopyParticipantsFromPreviousSeasonTournamentEnum];
/**
 * @export
 */
export const ParticipantControllerCreateParticipantTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type ParticipantControllerCreateParticipantTournamentEnum = typeof ParticipantControllerCreateParticipantTournamentEnum[keyof typeof ParticipantControllerCreateParticipantTournamentEnum];
/**
 * @export
 */
export const ParticipantControllerGetParticipantsTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type ParticipantControllerGetParticipantsTournamentEnum = typeof ParticipantControllerGetParticipantsTournamentEnum[keyof typeof ParticipantControllerGetParticipantsTournamentEnum];


/**
 * TournamentApi - axios parameter creator
 * @export
 */
export const TournamentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StageSubstitutionDto} stageSubstitutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerCreateStageSubstitution: async (stageSubstitutionDto: StageSubstitutionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stageSubstitutionDto' is not null or undefined
            assertParamExists('tournamentControllerCreateStageSubstitution', 'stageSubstitutionDto', stageSubstitutionDto)
            const localVarPath = `/tournament/create-stage-substitution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stageSubstitutionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {TournamentControllerCreateTournamentTournamentEnum} tournament 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerCreateTournament: async (season: string, tournament: TournamentControllerCreateTournamentTournamentEnum, requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('tournamentControllerCreateTournament', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('tournamentControllerCreateTournament', 'tournament', tournament)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('tournamentControllerCreateTournament', 'requestBody', requestBody)
            const localVarPath = `/tournament/{season}/{tournament}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerDeleteTournament: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tournamentControllerDeleteTournament', 'id', id)
            const localVarPath = `/tournament/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerGetSeasons: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tournament/seasons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} season 
         * @param {TournamentControllerGetStagesTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerGetStages: async (season: string, tournament: TournamentControllerGetStagesTournamentEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'season' is not null or undefined
            assertParamExists('tournamentControllerGetStages', 'season', season)
            // verify required parameter 'tournament' is not null or undefined
            assertParamExists('tournamentControllerGetStages', 'tournament', tournament)
            const localVarPath = `/tournament/{season}/{tournament}`
                .replace(`{${"season"}}`, encodeURIComponent(String(season)))
                .replace(`{${"tournament"}}`, encodeURIComponent(String(tournament)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentApi - functional programming interface
 * @export
 */
export const TournamentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TournamentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StageSubstitutionDto} stageSubstitutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tournamentControllerCreateStageSubstitution(stageSubstitutionDto: StageSubstitutionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageSubstitution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tournamentControllerCreateStageSubstitution(stageSubstitutionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TournamentApi.tournamentControllerCreateStageSubstitution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {TournamentControllerCreateTournamentTournamentEnum} tournament 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tournamentControllerCreateTournament(season: string, tournament: TournamentControllerCreateTournamentTournamentEnum, requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TournamentSeason>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tournamentControllerCreateTournament(season, tournament, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TournamentApi.tournamentControllerCreateTournament']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tournamentControllerDeleteTournament(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tournamentControllerDeleteTournament(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TournamentApi.tournamentControllerDeleteTournament']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tournamentControllerGetSeasons(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableTournament>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tournamentControllerGetSeasons(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TournamentApi.tournamentControllerGetSeasons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} season 
         * @param {TournamentControllerGetStagesTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tournamentControllerGetStages(season: string, tournament: TournamentControllerGetStagesTournamentEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Stage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tournamentControllerGetStages(season, tournament, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TournamentApi.tournamentControllerGetStages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TournamentApi - factory interface
 * @export
 */
export const TournamentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TournamentApiFp(configuration)
    return {
        /**
         * 
         * @param {StageSubstitutionDto} stageSubstitutionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerCreateStageSubstitution(stageSubstitutionDto: StageSubstitutionDto, options?: any): AxiosPromise<StageSubstitution> {
            return localVarFp.tournamentControllerCreateStageSubstitution(stageSubstitutionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {TournamentControllerCreateTournamentTournamentEnum} tournament 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerCreateTournament(season: string, tournament: TournamentControllerCreateTournamentTournamentEnum, requestBody: Array<string>, options?: any): AxiosPromise<TournamentSeason> {
            return localVarFp.tournamentControllerCreateTournament(season, tournament, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerDeleteTournament(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.tournamentControllerDeleteTournament(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerGetSeasons(options?: any): AxiosPromise<AvailableTournament> {
            return localVarFp.tournamentControllerGetSeasons(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} season 
         * @param {TournamentControllerGetStagesTournamentEnum} tournament 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tournamentControllerGetStages(season: string, tournament: TournamentControllerGetStagesTournamentEnum, options?: any): AxiosPromise<Array<Stage>> {
            return localVarFp.tournamentControllerGetStages(season, tournament, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TournamentApi - object-oriented interface
 * @export
 * @class TournamentApi
 * @extends {BaseAPI}
 */
export class TournamentApi extends BaseAPI {
    /**
     * 
     * @param {StageSubstitutionDto} stageSubstitutionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public tournamentControllerCreateStageSubstitution(stageSubstitutionDto: StageSubstitutionDto, options?: RawAxiosRequestConfig) {
        return TournamentApiFp(this.configuration).tournamentControllerCreateStageSubstitution(stageSubstitutionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {TournamentControllerCreateTournamentTournamentEnum} tournament 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public tournamentControllerCreateTournament(season: string, tournament: TournamentControllerCreateTournamentTournamentEnum, requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return TournamentApiFp(this.configuration).tournamentControllerCreateTournament(season, tournament, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public tournamentControllerDeleteTournament(id: number, options?: RawAxiosRequestConfig) {
        return TournamentApiFp(this.configuration).tournamentControllerDeleteTournament(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public tournamentControllerGetSeasons(options?: RawAxiosRequestConfig) {
        return TournamentApiFp(this.configuration).tournamentControllerGetSeasons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} season 
     * @param {TournamentControllerGetStagesTournamentEnum} tournament 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentApi
     */
    public tournamentControllerGetStages(season: string, tournament: TournamentControllerGetStagesTournamentEnum, options?: RawAxiosRequestConfig) {
        return TournamentApiFp(this.configuration).tournamentControllerGetStages(season, tournament, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TournamentControllerCreateTournamentTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type TournamentControllerCreateTournamentTournamentEnum = typeof TournamentControllerCreateTournamentTournamentEnum[keyof typeof TournamentControllerCreateTournamentTournamentEnum];
/**
 * @export
 */
export const TournamentControllerGetStagesTournamentEnum = {
    Ucl: 'UCL',
    Cwc: 'CWC',
    Uel: 'UEL',
    Uecl: 'UECL',
    Icfc: 'ICFC'
} as const;
export type TournamentControllerGetStagesTournamentEnum = typeof TournamentControllerGetStagesTournamentEnum[keyof typeof TournamentControllerGetStagesTournamentEnum];


